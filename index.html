<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Automata & Grammar Converter Tool</title>

  <!-- Font and Tailwind -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;600&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>

  <style>
    body {
      font-family: 'Roboto Mono', monospace;
      background-color: #f0f9ff;
      color: #1e293b;
    }

    .custom-container {
      max-width: 1080px;
      margin: auto;
      padding: 2rem;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .panel {
      background-color: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 0.75rem;
      padding: 1rem;
      box-shadow: 0 0 8px rgba(0,0,0,0.05);
    }

    .main-btn {
      background-color: #2563eb;
      color: white;
      padding: 0.5rem 1.2rem;
      border-radius: 0.5rem;
      font-weight: bold;
    }

    .main-btn:hover {
      background-color: #1d4ed8;
    }

    .secondary-btn {
      background-color: #e2e8f0;
      color: #1e293b;
      padding: 0.5rem 1.2rem;
      border-radius: 0.5rem;
    }

    .secondary-btn:hover {
      background-color: #cbd5e1;
    }

    .graph-box {
      height: 38vh;
      min-height: 240px;
      background-color: #ffffff;
      border: 2px solid #cbd5e1;
      border-radius: 0.75rem;
      overflow: hidden;
    }

    .step-box {
      background: #312e81;
      color: #dbeafe;
      padding: 1rem;
      border-radius: 0.75rem;
      font-family: 'Courier New', Courier, monospace;
      margin-top: 1rem;
      min-height: 240px;
      max-height: 320px;
      overflow-y: auto;
    }

    html::-webkit-scrollbar, body::-webkit-scrollbar, .graph-box::-webkit-scrollbar, .step-box::-webkit-scrollbar {
      display: none;
    }
  </style>
</head>
<body>
  <div class="custom-container">
    <header class="text-center mb-6">
      <h1 class="text-3xl font-bold text-blue-700">Automata & Grammar Converter Tool</h1>
      <p class="text-gray-600 mt-2">Interactive simulator for NFA→DFA, Epsilon NFA→DFA, and CFL→CFG conversions.</p>
    </header>

    <section class="panel mb-6">
      <div class="flex flex-col md:flex-row justify-between items-center gap-4">
        <div class="flex gap-4">
          <div>
            <label for="mode-picker" class="font-semibold mr-2">Mode:</label>
            <select id="mode-picker" class="p-2 border border-gray-300 rounded-md">
              <option value="nfa-dfa">NFA → DFA</option>
              <option value="epsilon-nfa-dfa">Epsilon NFA → DFA</option>
              <option value="cfl-cfg">CFL → CFG</option>
            </select>
          </div>
          <div>
            <label for="example-picker" class="font-semibold mr-2">Select Example:</label>
            <select id="example-picker" class="p-2 border border-gray-300 rounded-md"></select>
          </div>
        </div>
        <div class="flex gap-3">
          <button id="btnReset" class="secondary-btn">Start Over</button>
          <button id="btnNext" class="main-btn">Convert Step</button>
        </div>
      </div>
    </section>

    <div id="nfa-dfa-section" class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
      <div>
        <h2 class="text-xl font-semibold text-center mb-2 text-sky-700">Input NFA</h2>
        <div id="box-nfa" class="graph-box"></div>
      </div>
      <div>
        <h2 class="text-xl font-semibold text-center mb-2 text-indigo-700">Output DFA</h2>
        <div id="box-dfa" class="graph-box"></div>
      </div>
    </div>

    <div id="cfl-cfg-section" class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6" style="display: none;">
      <div>
        <h2 class="text-xl font-semibold text-center mb-2 text-sky-700">Context-Free Language (CFL)</h2>
        <div id="box-cfl" class="panel" style="height: 38vh; min-height: 240px; overflow-y: auto;">
          <div id="cfl-description" class="text-sm font-mono"></div>
        </div>
      </div>
      <div>
        <h2 class="text-xl font-semibold text-center mb-2 text-indigo-700">Context-Free Grammar (CFG)</h2>
        <div id="box-cfg" class="panel" style="height: 38vh; min-height: 240px; overflow-y: auto;">
          <div id="cfg-output" class="text-sm font-mono"></div>
        </div>
      </div>
    </div>

    <section>
      <h2 class="text-xl font-semibold mb-2 text-purple-700">Explanation Log</h2>
      <div id="log-box" class="step-box">Click “Convert Step” to visualize each step of the conversion.</div>
    </section>
  </div>

  <script>
    const standardNfaExamples = {
      "ends-01": {
        states: ['q0', 'q1', 'q2'], alphabet: ['0', '1'],
        transitions: {
          q0: { '0': ['q0', 'q1'], '1': ['q0'] },
          q1: { '1': ['q2'] }
        },
        startState: 'q0', finalStates: ['q2']
      },
      "contains-101": {
        states: ['q0', 'q1', 'q2', 'q3'], alphabet: ['0', '1'],
        transitions: {
          q0: { '0': ['q0'], '1': ['q0', 'q1'] },
          q1: { '0': ['q2'] },
          q2: { '1': ['q3'] }
        },
        startState: 'q0', finalStates: ['q3']
      },
      "even-0s": {
        states: ['q0', 'q1'], alphabet: ['0', '1'],
        transitions: {
          q0: { '0': ['q1'], '1': ['q0'] },
          q1: { '0': ['q0'], '1': ['q1'] }
        },
        startState: 'q0', finalStates: ['q0']
      },
      "starts-1": {
        states: ['s0', 's1'], alphabet: ['0', '1'],
        transitions: {
          s0: { '1': ['s1'] },
          s1: { '0': ['s1'], '1': ['s1'] }
        },
        startState: 's0', finalStates: ['s1']
      },
      "palindrome": {
        states: ['p0', 'p1', 'p2'], alphabet: ['0', '1'],
        transitions: {
          p0: { '0': ['p1'], '1': ['p2'] },
          p1: { '0': ['p0'] },
          p2: { '1': ['p0'] }
        },
        startState: 'p0', finalStates: ['p0']
      },
      "only-0": {
        states: ['a', 'b'], alphabet: ['0', '1'],
        transitions: {
          a: { '0': ['a'], '1': ['b'] },
          b: { '0': ['b'], '1': ['b'] }
        },
        startState: 'a', finalStates: ['a']
      },
      "alternate-01": {
        states: ['x0', 'x1'], alphabet: ['0', '1'],
        transitions: {
          x0: { '0': ['x1'] },
          x1: { '1': ['x0'] }
        },
        startState: 'x0', finalStates: ['x0']
      },
      "ends-0": {
        states: ['e0', 'e1'], alphabet: ['0', '1'],
        transitions: {
          e0: { '0': ['e1'], '1': ['e0'] },
          e1: { '0': ['e1'], '1': ['e0'] }
        },
        startState: 'e0', finalStates: ['e1']
      }
    };

    const epsilonNfaExamples = {
      "epsilon-basic": {
        states: ['q0', 'q1', 'q2'], alphabet: ['a', 'b'],
        transitions: {
          q0: { 'ε': ['q1'], 'b': ['q2'] },
          q1: { 'a': ['q2'] }
        },
        startState: 'q0', finalStates: ['q2']
      },
      "epsilon-complex": {
        states: ['q0', 'q1', 'q2', 'q3'], alphabet: ['a', 'b'],
        transitions: {
          q0: { 'ε': ['q1', 'q2'], 'a': ['q3'] },
          q1: { 'b': ['q3'] },
          q2: { 'ε': ['q3'], 'a': ['q1'] },
          q3: { 'a': ['q0'], 'b': ['q0'] }
        },
        startState: 'q0', finalStates: ['q3']
      },
      "epsilon-chain": {
        states: ['s0', 's1', 's2', 's3'], alphabet: ['x', 'y'],
        transitions: {
          s0: { 'ε': ['s1'] },
          s1: { 'ε': ['s2'], 'x': ['s3'] },
          s2: { 'y': ['s3'] },
          s3: {}
        },
        startState: 's0', finalStates: ['s3']
      },
      "epsilon-optional": {
        states: ['p0', 'p1', 'p2'], alphabet: ['a', 'b'],
        transitions: {
          p0: { 'a': ['p1'], 'ε': ['p2'] },
          p1: { 'b': ['p2'] },
          p2: {}
        },
        startState: 'p0', finalStates: ['p2']
      },
      "epsilon-union": {
        states: ['r0', 'r1', 'r2', 'r3'], alphabet: ['0', '1'],
        transitions: {
          r0: { 'ε': ['r1', 'r2'] },
          r1: { '0': ['r3'] },
          r2: { '1': ['r3'] },
          r3: {}
        },
        startState: 'r0', finalStates: ['r3']
      }
    };

    const cflExamples = {
      "balanced-parentheses": {
        description: "L = {w | w contains balanced parentheses}",
        examples: ["()", "(())", "()()", "((()))", "(()())"],
        nonExamples: ["(", ")", "(()", "())", ")("],
        explanation: "Language of all strings with properly balanced parentheses"
      },
      "palindromes": {
        description: "L = {w | w = w^R, w ∈ {a,b}*}",
        examples: ["ε", "a", "b", "aa", "bb", "aba", "bab", "abba", "baab"],
        nonExamples: ["ab", "ba", "aab", "abb", "abab"],
        explanation: "Language of all palindromes over alphabet {a,b}"
      },
      "equal-ab": {
        description: "L = {w | #a(w) = #b(w), w ∈ {a,b}*}",
        examples: ["ε", "ab", "ba", "aabb", "abab", "baba", "baab"],
        nonExamples: ["a", "b", "aa", "bb", "aaa", "aaab"],
        explanation: "Language of strings with equal number of a's and b's"
      },
      "anbn": {
        description: "L = {a^n b^n | n ≥ 0}",
        examples: ["ε", "ab", "aabb", "aaabbb", "aaaabbbb"],
        nonExamples: ["a", "b", "aa", "bb", "aba", "bab", "aab", "abb"],
        explanation: "Language of strings with n a's followed by n b's"
      },
      "wcwr": {
        description: "L = {wcw^R | w ∈ {a,b}*}",
        examples: ["c", "aca", "bcb", "aaca", "abcba", "bacab"],
        nonExamples: ["", "a", "b", "ac", "ca", "abc", "cba"],
        explanation: "Language of strings w followed by c followed by reverse of w"
      }
    };

    const modePicker = document.getElementById('mode-picker');
    const examplePicker = document.getElementById('example-picker');
    const nfaDfaSection = document.getElementById('nfa-dfa-section');
    const cflCfgSection = document.getElementById('cfl-cfg-section');
    const boxNFA = document.getElementById('box-nfa');
    const boxDFA = document.getElementById('box-dfa');
    const cflDescription = document.getElementById('cfl-description');
    const cfgOutput = document.getElementById('cfg-output');
    const btnNext = document.getElementById('btnNext');
    const btnReset = document.getElementById('btnReset');
    const logBox = document.getElementById('log-box');

    let currentMode = 'nfa-dfa';
    let allSteps = [], currentIndex = -1;

    function populateExamples() {
      examplePicker.innerHTML = '';
      let examples;
      if (currentMode === 'nfa-dfa') {
        examples = standardNfaExamples;
      } else if (currentMode === 'epsilon-nfa-dfa') {
        examples = epsilonNfaExamples;
      } else {
        examples = cflExamples;
      }
      Object.keys(examples).forEach(key => {
        const opt = document.createElement('option');
        opt.value = key;
        opt.textContent = key.replace(/-/g, ' ');
        examplePicker.appendChild(opt);
      });
    }

    function switchMode() {
      currentMode = modePicker.value;
      if (currentMode === 'nfa-dfa' || currentMode === 'epsilon-nfa-dfa') {
        nfaDfaSection.style.display = 'grid';
        cflCfgSection.style.display = 'none';
      } else {
        nfaDfaSection.style.display = 'none';
        cflCfgSection.style.display = 'grid';
      }
      populateExamples();
      beginSimulation();
    }

    function createGraph(container, automaton) {
      const nodes = new vis.DataSet();
      const edges = new vis.DataSet();
      nodes.add({ id: 'start_ref', hidden: true });
      automaton.states.forEach(state => {
        const isFinal = automaton.finalStates.includes(state);
        nodes.add({
          id: state,
          label: state,
          shape: 'circle',
          color: {
            background: '#fff',
            border: isFinal ? '#f59e0b' : '#2563eb'
          },
          borderWidth: isFinal ? 4 : 2
        });
        if (state === automaton.startState) {
          edges.add({ from: 'start_ref', to: state, arrows: 'to', color: { color: '#22c55e' } });
        }
      });
      for (const from in automaton.transitions) {
        for (const sym in automaton.transitions[from]) {
          const toStates = Array.isArray(automaton.transitions[from][sym]) ? automaton.transitions[from][sym] : [automaton.transitions[from][sym]];
          toStates.forEach(to => {
            edges.add({ from, to, label: sym, arrows: 'to', color: '#6b7280' });
          });
        }
      }
      new vis.Network(container.firstElementChild, { nodes, edges }, { layout: { improvedLayout: true }, physics: false });
    }

    function convertEpsilon(states, transitions) {
      const stack = [...states], closure = new Set(states);
      while (stack.length) {
        const state = stack.pop();
        const eps = transitions[state]?.['ε'] || [];
        for (const next of eps) if (!closure.has(next)) closure.add(next), stack.push(next);
      }
      return [...closure].sort();
    }

    function generateSteps(nfa) {
      const queue = [], steps = [], seen = new Map();
      const dfaStates = [], dfaFinal = [], dfaTrans = {};
      
      // Step 1: Calculate ε-closure of the NFA's start state
      const initialEpsilonClosure = convertEpsilon([nfa.startState], nfa.transitions);
      const initialDFAStateKey = initialEpsilonClosure.join(',');
      
      queue.push(initialEpsilonClosure);
      seen.set(initialDFAStateKey, 'Q0');
      dfaStates.push(initialDFAStateKey);
      dfaTrans[initialDFAStateKey] = {};
      
      if (initialEpsilonClosure.some(s => nfa.finalStates.includes(s))) {
        dfaFinal.push(initialDFAStateKey);
      }
      
      steps.push(`Step 1: Calculate ε-closure of the NFA's start state (${nfa.startState}).`);
      steps.push(`ε-closure(${nfa.startState}) = {${initialEpsilonClosure.join(', ')}}`);
      steps.push(`This forms the initial DFA state: Q0 = {${initialDFAStateKey}}.`);
      steps.push({ dfa: { states: [initialDFAStateKey], alphabet: nfa.alphabet, transitions: {}, startState: initialDFAStateKey, finalStates: [...dfaFinal] } });

      let count = 1;

      while (queue.length) {
        const currentNFAStates = queue.shift();
        const currentDFAStateLabel = seen.get(currentNFAStates.join(','));
        const currentDFAStateKey = currentNFAStates.join(',');

        steps.push(`\nStep ${count + 1}: Process DFA state ${currentDFAStateLabel} = {${currentDFAStateKey}}.`);

        for (const symbol of nfa.alphabet) {
          if (symbol === 'ε') continue; // Skip epsilon transitions for DFA conversion

          steps.push(`  For input symbol '${symbol}':`);
          let nextStatesAfterSymbol = new Set();
          currentNFAStates.forEach(nfaState => {
            const transitionsForSymbol = nfa.transitions[nfaState]?.[symbol] || [];
            transitionsForSymbol.forEach(targetState => {
              nextStatesAfterSymbol.add(targetState);
            });
          });

          const nextStatesArr = [...nextStatesAfterSymbol].sort();
          steps.push(`    States reachable from {${currentNFAStates.join(', ')}} on '${symbol}' are {${nextStatesArr.join(', ') || '∅'}}. `);

          if (nextStatesArr.length === 0) {
            steps.push(`    No new state formed for '${symbol}'.`);
            continue;
          }

          const epsilonClosureOfNextStates = new Set();
          nextStatesArr.forEach(state => {
            convertEpsilon([state], nfa.transitions).forEach(s => epsilonClosureOfNextStates.add(s));
          });
          const nextDFAStateArr = [...epsilonClosureOfNextStates].sort();
          const nextDFAStateKey = nextDFAStateArr.join(',');
          const nextDFAStateLabel = seen.has(nextDFAStateKey) ? seen.get(nextDFAStateKey) : `Q${count}`; // Use current count for new state

          steps.push(`    Calculate ε-closure of {${nextStatesArr.join(', ')}} which is {${nextDFAStateArr.join(', ')}}.`);

          if (!seen.has(nextDFAStateKey)) {
            seen.set(nextDFAStateKey, `Q${count++}`);
            queue.push(nextDFAStateArr);
            dfaStates.push(nextDFAStateKey);
            dfaTrans[nextDFAStateKey] = {};
            if (nextDFAStateArr.some(s => nfa.finalStates.includes(s))) {
              dfaFinal.push(nextDFAStateKey);
            }
            steps.push(`    This is a new DFA state: ${seen.get(nextDFAStateKey)} = {${nextDFAStateKey}}. Add to queue.`);
          } else {
            steps.push(`    This state (${nextDFAStateLabel}) has already been processed.`);
          }
          
          dfaTrans[currentDFAStateKey][symbol] = nextDFAStateKey;
          steps.push(`    Add transition: ${currentDFAStateLabel} --${symbol}→ ${seen.get(nextDFAStateKey)}.`);
          
          // Update DFA graph after each transition is added
          const currentDFA = {
            states: [...dfaStates],
            alphabet: nfa.alphabet,
            transitions: {},
            startState: initialDFAStateKey,
            finalStates: [...dfaFinal]
          };
          // Deep copy transitions to avoid reference issues
          for (const state in dfaTrans) {
            currentDFA.transitions[state] = { ...dfaTrans[state] };
          }
          steps.push({ dfa: currentDFA });
        }
      }
      return steps;
    }

    function generateCFGSteps(cfl) {
      const steps = [];
      const cflData = cflExamples[cfl];
      
      steps.push(`Step 1: Analyze the Context-Free Language`);
      steps.push(`Language: ${cflData.description}`);
      steps.push(`Examples: ${cflData.examples.join(', ')}`);
      steps.push(`Non-examples: ${cflData.nonExamples.join(', ')}`);
      steps.push(`Explanation: ${cflData.explanation}`);
      
      let cfg = '';
      
      switch(cfl) {
        case 'balanced-parentheses':
          steps.push(`\nStep 2: Construct CFG for balanced parentheses`);
          steps.push(`The language requires matching opening and closing parentheses.`);
          steps.push(`We can define this recursively:`);
          cfg = `S → ε | (S) | SS`;
          steps.push(`Production rules:`);
          steps.push(`S → ε     (empty string is balanced)`);
          steps.push(`S → (S)   (wrap balanced string in parentheses)`);
          steps.push(`S → SS    (concatenate two balanced strings)`);
          break;
          
        case 'palindromes':
          steps.push(`\nStep 2: Construct CFG for palindromes over {a,b}`);
          steps.push(`A palindrome reads the same forwards and backwards.`);
          steps.push(`We can build palindromes by adding matching symbols to both ends:`);
          cfg = `S → ε | a | b | aSa | bSb`;
          steps.push(`Production rules:`);
          steps.push(`S → ε     (empty string is a palindrome)`);
          steps.push(`S → a     (single 'a' is a palindrome)`);
          steps.push(`S → b     (single 'b' is a palindrome)`);
          steps.push(`S → aSa   (add 'a' to both ends of palindrome)`);
          steps.push(`S → bSb   (add 'b' to both ends of palindrome)`);
          break;
          
        case 'equal-ab':
          steps.push(`\nStep 2: Construct CFG for equal number of a's and b's`);
          steps.push(`We need to ensure #a(w) = #b(w) for any string w.`);
          steps.push(`We can interleave a's and b's or group them:`);
          cfg = `S → ε | aSb | bSa | SS`;
          steps.push(`Production rules:`);
          steps.push(`S → ε     (empty string has 0 a's and 0 b's)`);
          steps.push(`S → aSb   (add one 'a' and one 'b')`);
          steps.push(`S → bSa   (add one 'b' and one 'a')`);
          steps.push(`S → SS    (concatenate two balanced strings)`);
          break;
          
        case 'anbn':
          steps.push(`\nStep 2: Construct CFG for a^n b^n`);
          steps.push(`We need exactly n a's followed by exactly n b's.`);
          steps.push(`This is a classic context-free language:`);
          cfg = `S → ε | aSb`;
          steps.push(`Production rules:`);
          steps.push(`S → ε     (n=0: empty string)`);
          steps.push(`S → aSb   (add one 'a' at start and one 'b' at end)`);
          break;
          
        case 'wcwr':
          steps.push(`\nStep 2: Construct CFG for wcw^R`);
          steps.push(`We need a string w, followed by 'c', followed by reverse of w.`);
          steps.push(`The 'c' acts as a center marker:`);
          cfg = `S → c | aSa | bSb`;
          steps.push(`Production rules:`);
          steps.push(`S → c     (w is empty, so we have just 'c')`);
          steps.push(`S → aSa   (add 'a' to both ends around the center)`);
          steps.push(`S → bSb   (add 'b' to both ends around the center)`);
          break;
      }
      
      steps.push(`\nStep 3: Final Context-Free Grammar`);
      steps.push(`CFG: ${cfg}`);
      steps.push({ cfg: cfg });
      
      return steps;
    }

    function beginSimulation() {
      if (currentMode === 'nfa-dfa' || currentMode === 'epsilon-nfa-dfa') {
        let nfa;
        if (currentMode === 'nfa-dfa') {
          nfa = standardNfaExamples[examplePicker.value];
        } else {
          nfa = epsilonNfaExamples[examplePicker.value];
        }
        boxNFA.innerHTML = boxDFA.innerHTML = '<div style="height:100%"></div>';
        setTimeout(() => {
          createGraph(boxNFA, nfa);
          createGraph(boxDFA, { states: [], alphabet: [], transitions: {}, startState: '', finalStates: [] });
        }, 50);
        allSteps = generateSteps(nfa);
        currentIndex = -1;
        logBox.innerHTML = "Click \u201cConvert Step\u201d to visualize each step of the conversion.";
        btnNext.disabled = false;
      } else {
        const cfl = cflExamples[examplePicker.value];
        cflDescription.innerHTML = `
          <h3 class="font-bold mb-2">Language Description:</h3>
          <p class="mb-2">${cfl.description}</p>
          <p class="mb-2"><strong>Explanation:</strong> ${cfl.explanation}</p>
          <p class="mb-2"><strong>Examples:</strong> ${cfl.examples.join(', ')}</p>
          <p class="mb-2"><strong>Non-examples:</strong> ${cfl.nonExamples.join(', ')}</p>
        `;
        cfgOutput.innerHTML = 'Click "Convert Step" to generate the Context-Free Grammar.';
        allSteps = generateCFGSteps(examplePicker.value);
        currentIndex = -1;
        logBox.innerHTML = "Click \u201cConvert Step\u201d to generate the CFG step by step.";
        btnNext.disabled = false;
      }
    }

    function nextConversionStep() {
      currentIndex++;
      if (currentIndex < allSteps.length) {
        const step = allSteps[currentIndex];
        if (typeof step === 'string') {
          logBox.innerHTML = step;
        } else if (step.dfa && (currentMode === 'nfa-dfa' || currentMode === 'epsilon-nfa-dfa')) {
          boxDFA.innerHTML = '<div style="height:100%"></div>';
          setTimeout(() => createGraph(boxDFA, step.dfa), 50);
          logBox.innerHTML += '<br>DFA graph updated.';
        } else if (step.cfg && currentMode === 'cfl-cfg') {
          cfgOutput.innerHTML = `<h3 class="font-bold mb-2">Generated Context-Free Grammar:</h3><p class="text-lg font-mono">${step.cfg}</p>`;
          logBox.innerHTML += '<br>CFG generated.';
        }
      } else {
        btnNext.disabled = true;
        if (currentMode === 'nfa-dfa' || currentMode === 'epsilon-nfa-dfa') {
          const finalDFA = allSteps[allSteps.length - 1].dfa;
          let summary = `<br><br><span class='text-green-400 font-bold'>✅ Conversion Completed!</span><br>`;
          summary += `<strong>DFA States:</strong> {${Object.values(finalDFA.states).map(s => seen.get(s) || s).join(', ')}}<br>`;
          summary += `<strong>Alphabet:</strong> {${finalDFA.alphabet.join(', ')}}<br>`;
          summary += `<strong>Start State:</strong> ${seen.get(finalDFA.startState) || finalDFA.startState}<br>`;
          summary += `<strong>Final States:</strong> {${finalDFA.finalStates.map(s => seen.get(s) || s).join(', ')}}<br>`;
          summary += `<strong>Transitions:</strong><br>`;
          for (const [fromKey, trans] of Object.entries(finalDFA.transitions)) {
            const fromLabel = seen.get(fromKey) || fromKey;
            for (const [symbol, toKey] of Object.entries(trans)) {
              const toLabel = seen.get(toKey) || toKey;
              summary += `&nbsp;&nbsp;&nbsp;&nbsp;${fromLabel} --${symbol}→ ${toLabel}<br>`;
            }
          }
          logBox.innerHTML += summary;
        } else {
          logBox.innerHTML += `<br><br><span class='text-green-400 font-bold'>✅ CFG Generation Completed!</span><br>`;
          logBox.innerHTML += `The Context-Free Grammar has been successfully generated for the given language.`;
        }
      }
    }

    modePicker.onchange = switchMode;
    btnReset.onclick = beginSimulation;
    btnNext.onclick = nextConversionStep;
    window.onload = () => {
      populateExamples();
      beginSimulation();
    };
  </script>
</body>
</html>


